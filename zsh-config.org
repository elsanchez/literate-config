* Zsh Configuration (Literate)

This is your literate Zsh setup for KDE, Doom Emacs, and powerlevel10k.

---

** Global Environment

#+PROPERTY: header-args :results none
#+begin_src shell :tangle ~/.zshrc
# Instant Prompt loading for faster startup
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Oh My Zsh setup
export ZSH="$HOME/.oh-my-zsh"

# Check if Oh My Zsh exists
if [[ ! -d "$ZSH" ]]; then
  echo "‚ö†Ô∏è  Oh My Zsh not found. Install it with:"
  echo "sh -c \"\$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\""
  return 1
fi

# Check if powerlevel10k theme exists
if [[ -d "$ZSH/custom/themes/powerlevel10k" ]]; then
  ZSH_THEME="powerlevel10k/powerlevel10k"
else
  echo "‚ö†Ô∏è  Powerlevel10k theme not found. Install it with:"
  echo "git clone --depth=1 https://github.com/romkatv/powerlevel10k.git \$ZSH_CUSTOM/themes/powerlevel10k"
  ZSH_THEME="robbyrussell"  # Fallback theme
fi

# Check and setup plugins
declare -a available_plugins=()
declare -a missing_plugins=()

# Define desired plugins
desired_plugins=(git zsh-autosuggestions zsh-syntax-highlighting direnv uv tmux)

for plugin in "${desired_plugins[@]}"; do
  case $plugin in
    git|tmux) 
      # Built-in plugins
      available_plugins+=($plugin)
      ;;
    zsh-autosuggestions)
      if [[ -d "$ZSH/custom/plugins/zsh-autosuggestions" ]]; then
        available_plugins+=($plugin)
      else
        missing_plugins+=($plugin)
      fi
      ;;
    zsh-syntax-highlighting)
      if [[ -d "$ZSH/custom/plugins/zsh-syntax-highlighting" ]]; then
        available_plugins+=($plugin)
      else
        missing_plugins+=($plugin)
      fi
      ;;
    direnv|uv)
      if command -v $plugin >/dev/null 2>&1; then
        available_plugins+=($plugin)
      else
        missing_plugins+=($plugin)
      fi
      ;;
  esac
done

# Report missing plugins
if [[ ${#missing_plugins[@]} -gt 0 ]]; then
  echo "‚ö†Ô∏è  Missing zsh plugins: ${missing_plugins[*]}"
  echo "Install missing plugins:"
  for plugin in "${missing_plugins[@]}"; do
    case $plugin in
      zsh-autosuggestions)
        echo "  git clone https://github.com/zsh-users/zsh-autosuggestions \$ZSH_CUSTOM/plugins/zsh-autosuggestions"
        ;;
      zsh-syntax-highlighting)
        echo "  git clone https://github.com/zsh-users/zsh-syntax-highlighting.git \$ZSH_CUSTOM/plugins/zsh-syntax-highlighting"
        ;;
      direnv)
        echo "  sudo apt install direnv  # or: curl -sfL https://direnv.net/install.sh | bash"
        ;;
      uv)
        echo "  curl -LsSf https://astral.sh/uv/install.sh | sh"
        ;;
    esac
  done
fi

# Set available plugins
plugins=(${available_plugins[@]})

# Load Oh My Zsh
source $ZSH/oh-my-zsh.sh

# Load Powerlevel10k configuration if available
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# Set environment variables
export EDITOR='emacs'
export BROWSER='firefox'

# Setup PATH for pipx if installed
if command -v pipx > /dev/null 2>&1; then
  export PATH="$PATH:~/.local/bin"
fi

# Setup emacs, npm, nvim environment
export PATH="$PATH:$HOME/.config/emacs/bin:$HOME/.npm-global/bin:/opt/nvim-linux-x86_64/bin"

# Golang environment
if [[ -d "/usr/local/go/bin" ]]; then
  export PATH=$PATH:/usr/local/go/bin
  export GOPATH=$HOME/go
  export PATH=$PATH:$GOPATH/bin
fi

# Aliases
# Navigation and general
alias ll='ls -lh --color=auto'
alias la='ls -lAh --color=auto'
alias gs='git status'
alias reload!='source ~/.zshrc'
alias please='sudo'
alias cls='clear'

# APT package management (short form)
alias api='sudo apt install'
alias apr='sudo apt remove'
alias app='sudo apt purge'
alias aps='apt search'
alias apu='sudo apt update && sudo apt upgrade'
alias apc='sudo apt autoremove'
alias apf='sudo apt --fix-broken install'
alias apsh='apt show'
alias pbcopy="xsel --clipboard --input"
alias yt='download_video'
alias open='dolphin'
alias via='mosh --ssh="ssh -i ~/.ssh/id_ed25519" linuxuser@107.191.55.XX'
alias restart-audio='systemctl --user restart pipewire pipewire-pulse wireplumber || (pulseaudio -k && pulseaudio --start)'

# General options
setopt correct
setopt autocd
setopt extended_glob

# Completion system
autoload -Uz compinit && compinit

# Create a directory and move into it
mkcd() {
  mkdir -p "$1" && cd "$1"
}

# Quickly navigate up N directories
up() {
  local d=""
  limit=$1
  for ((i=1; i<=limit; i++)); do
    d="../$d"
  done
  cd "$d"
}

# Open current directory in Dolphin
dolphin() {
  nohup dolphin . >/dev/null 2>&1 &
}

# Open a file quickly with Emacs
e() {
  emacs -nw "$@"
}

download_video() {
  local url=$1
  local output_filename=$2
  local output_dir=~/Downloads/videos
  
  if [[ -z "$url" ]]; then
    echo "‚ùå Usage: download_video <url> [filename]"
    return 1
  fi
  
  mkdir -p "$output_dir"

  case "$url" in
    ,*instagram.com*|*deviantart.com*)
      if ! command -v gallery-dl >/dev/null 2>&1; then
        echo "‚ùå gallery-dl not found. Install with: pip install gallery-dl"
        return 1
      fi
      cookies_file=~/Documents/cookies.instagram.txt
      gallery-dl --cookies ${cookies_file} \
               --output "$output_dir/${output_filename}.%(extension)s" "$url"
      ;;
    ,*x.com*)
      if ! command -v yt-dlp >/dev/null 2>&1; then
        echo "‚ùå yt-dlp not found. Install with: pip install yt-dlp"
        return 1
      fi
      cookies_file=~/Documents/cookies.twitter.txt
      yt-dlp --cookies ${cookies_file} -o "${output_dir}/${output_filename}.%(ext)s" "$url"
      ;;
    ,*)
      if ! command -v yt-dlp >/dev/null 2>&1; then
        echo "‚ùå yt-dlp not found. Install with: pip install yt-dlp"
        return 1
      fi
      yt-dlp -o "${output_dir}/${output_filename}.%(ext)s" "$url"
      ;;
  esac
}

# Lista y selecciona una sesi√≥n tmux con fzf
tms() {
  if ! command -v tmux >/dev/null 2>&1; then
    echo "‚ùå tmux not found. Install with: sudo apt install tmux"
    return 1
  fi
  
  if ! command -v fzf >/dev/null 2>&1; then
    echo "‚ùå fzf not found. Install with: sudo apt install fzf"
    return 1
  fi
  
  local session
  session=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | fzf --prompt="üîç Tmux session: ")

  if [ -n "$session" ]; then
    tmux attach-session -t "$session"
  else
    echo "‚ùå No session selected."
  fi
}

# Crea o conecta a una sesi√≥n (por nombre o default)
tmgo() {
  if ! command -v tmux >/dev/null 2>&1; then
    echo "‚ùå tmux not found. Install with: sudo apt install tmux"
    return 1
  fi
  
  local session="${1:-default}"
  tmux has-session -t "$session" 2>/dev/null

  if [ $? != 0 ]; then
    echo "üì¶ Creating session '$session'"
    tmux new-session -s "$session"
  else
    echo "üîÑ Attaching to session '$session'"
    tmux attach-session -t "$session"
  fi
}

# Mata sesi√≥n desde fzf
tmkill() {
  if ! command -v tmux >/dev/null 2>&1; then
    echo "‚ùå tmux not found. Install with: sudo apt install tmux"
    return 1
  fi
  
  if ! command -v fzf >/dev/null 2>&1; then
    echo "‚ùå fzf not found. Install with: sudo apt install fzf"
    return 1
  fi
  
  local session
  session=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | fzf --prompt="‚ùå Kill session: ")

  if [ -n "$session" ]; then
    tmux kill-session -t "$session"
    echo "üí• Session '$session' killed."
  else
    echo "‚ùå No session selected."
  fi
}

# Enhanced Configuration management with symlinks and versioning
config-backup() {
  local backup_dir="$HOME/.config-backups"
  local timestamp=$(date +"%Y%m%d_%H%M%S")
  
  echo "üì¶ Creating configuration backup..."
  mkdir -p "$backup_dir"
  
  # Initialize git repo if it doesn't exist
  if [[ ! -d "$backup_dir/.git" ]]; then
    cd "$backup_dir"
    git init
    git config user.name "Config Backup"
    git config user.email "backup@localhost"
    echo "‚úÖ Initialized backup repository"
  fi
  
  cd "$backup_dir"
  
  # Copy current configs with better organization
  echo "üíæ Backing up configurations..."
  [[ -f ~/.zshrc ]] && cp ~/.zshrc "zshrc_$timestamp"
  [[ -d ~/.config/doom ]] && cp -r ~/.config/doom "doom_$timestamp"
  [[ -f ~/.p10k.zsh ]] && cp ~/.p10k.zsh "p10k_$timestamp.zsh"
  
  # Commit backup
  git add .
  git commit -m "Backup $timestamp" >/dev/null 2>&1
  
  echo "‚úÖ Backup created: $timestamp"
  echo "üìÅ Location: $backup_dir"
}

# Enhanced system with symlinks and proper versioning
config-init-dotfiles() {
  echo "üîó Initializing dotfiles repository with symlinks..."
  
  local dotfiles_dir="$HOME/.dotfiles"
  local config_source="$HOME/org/literate-config"
  
  # Create dotfiles directory
  mkdir -p "$dotfiles_dir"
  cd "$dotfiles_dir"
  
  # Initialize git repo if needed
  if [[ ! -d ".git" ]]; then
    git init
    git config user.name "$(git config --global user.name || echo 'Config Manager')"
    git config user.email "$(git config --global user.email || echo 'config@localhost')"
    echo "‚úÖ Initialized dotfiles repository"
  fi
  
  # Create directory structure
  mkdir -p doom zsh scripts backups
  
  # Move existing configs to dotfiles repo (if they exist)
  echo "üìÅ Organizing configuration files..."
  
  # Handle .zshrc
  if [[ -f ~/.zshrc && ! -L ~/.zshrc ]]; then
    echo "üíæ Moving ~/.zshrc to dotfiles repo..."
    mv ~/.zshrc "$dotfiles_dir/zsh/zshrc"
    git add zsh/zshrc
  fi
  
  # Handle .p10k.zsh
  if [[ -f ~/.p10k.zsh && ! -L ~/.p10k.zsh ]]; then
    echo "üíæ Moving ~/.p10k.zsh to dotfiles repo..."
    mv ~/.p10k.zsh "$dotfiles_dir/zsh/p10k.zsh"
    git add zsh/p10k.zsh
  fi
  
  # Handle doom config
  if [[ -d ~/.config/doom && ! -L ~/.config/doom ]]; then
    echo "üíæ Moving ~/.config/doom to dotfiles repo..."
    mv ~/.config/doom "$dotfiles_dir/doom/config"
    git add doom/
  fi
  
  # Initial commit
  if git status --porcelain | grep -q .; then
    git commit -m "Initial dotfiles setup - moved existing configs"
    echo "‚úÖ Initial dotfiles commit created"
  fi
  
  echo "üîó Setting up symlinks..."
  config-create-symlinks
}

config-create-symlinks() {
  local dotfiles_dir="$HOME/.dotfiles"
  
  if [[ ! -d "$dotfiles_dir" ]]; then
    echo "‚ùå Dotfiles directory not found. Run config-init-dotfiles first."
    return 1
  fi
  
  echo "üîó Creating symbolic links..."
  
  # Create necessary directories
  mkdir -p ~/.config
  
  # Symlink zsh files
  if [[ -f "$dotfiles_dir/zsh/zshrc" ]]; then
    [[ -L ~/.zshrc ]] && rm ~/.zshrc
    [[ -f ~/.zshrc ]] && mv ~/.zshrc ~/.zshrc.backup.$(date +%Y%m%d_%H%M%S)
    ln -sf "$dotfiles_dir/zsh/zshrc" ~/.zshrc
    echo "‚úÖ Linked ~/.zshrc"
  fi
  
  if [[ -f "$dotfiles_dir/zsh/p10k.zsh" ]]; then
    [[ -L ~/.p10k.zsh ]] && rm ~/.p10k.zsh
    [[ -f ~/.p10k.zsh ]] && mv ~/.p10k.zsh ~/.p10k.zsh.backup.$(date +%Y%m%d_%H%M%S)
    ln -sf "$dotfiles_dir/zsh/p10k.zsh" ~/.p10k.zsh
    echo "‚úÖ Linked ~/.p10k.zsh"
  fi
  
  # Symlink doom config
  if [[ -d "$dotfiles_dir/doom/config" ]]; then
    [[ -L ~/.config/doom ]] && rm ~/.config/doom
    [[ -d ~/.config/doom ]] && mv ~/.config/doom ~/.config/doom.backup.$(date +%Y%m%d_%H%M%S)
    ln -sf "$dotfiles_dir/doom/config" ~/.config/doom
    echo "‚úÖ Linked ~/.config/doom"
  fi
  
  echo "üîó Symlinks created successfully!"
}

config-sync-to-dotfiles() {
  echo "üîÑ Syncing generated configs to dotfiles repository..."
  
  local dotfiles_dir="$HOME/.dotfiles"
  local config_source="$HOME/org/literate-config"
  
  if [[ ! -d "$dotfiles_dir" ]]; then
    echo "‚ùå Dotfiles directory not found. Run config-init-dotfiles first."
    return 1
  fi
  
  cd "$dotfiles_dir"
  
  # Copy latest generated configs
  echo "üìã Copying generated configurations..."
  
  # Copy zshrc if it's not a symlink (i.e., freshly generated)
  if [[ -f ~/.zshrc && ! -L ~/.zshrc ]]; then
    cp ~/.zshrc zsh/zshrc
    echo "‚úÖ Synced .zshrc"
  elif [[ -L ~/.zshrc ]]; then
    echo "‚ÑπÔ∏è  .zshrc is already symlinked"
  fi
  
  # Copy doom config if it's not a symlink
  if [[ -d ~/.config/doom && ! -L ~/.config/doom ]]; then
    rm -rf doom/config
    cp -r ~/.config/doom doom/config
    echo "‚úÖ Synced doom config"
  elif [[ -L ~/.config/doom ]]; then
    echo "‚ÑπÔ∏è  doom config is already symlinked"
  fi
  
  # Copy p10k config
  if [[ -f ~/.p10k.zsh && ! -L ~/.p10k.zsh ]]; then
    cp ~/.p10k.zsh zsh/p10k.zsh
    echo "‚úÖ Synced .p10k.zsh"
  elif [[ -L ~/.p10k.zsh ]]; then
    echo "‚ÑπÔ∏è  .p10k.zsh is already symlinked"
  fi
  
  # Commit changes
  if git status --porcelain | grep -q .; then
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    git add .
    git commit -m "Sync configs $timestamp - $(git status --porcelain | wc -l) files changed"
    echo "‚úÖ Changes committed to dotfiles repo"
  else
    echo "‚ÑπÔ∏è  No changes to commit"
  fi
}

config-status() {
  echo "üìä Configuration status:"
  
  local dotfiles_dir="$HOME/.dotfiles"
  
  # Check if dotfiles repo exists
  if [[ -d "$dotfiles_dir/.git" ]]; then
    echo "‚úÖ Dotfiles repository: $dotfiles_dir"
    cd "$dotfiles_dir"
    echo "üìã Repository status:"
    git log --oneline -5 | sed 's/^/  /'
  else
    echo "‚ùå No dotfiles repository found"
    echo "üí° Run 'config-init-dotfiles' to set up"
  fi
  
  echo ""
  echo "üîó Symlink status:"
  
  # Check symlinks
  if [[ -L ~/.zshrc ]]; then
    echo "‚úÖ ~/.zshrc ‚Üí $(readlink ~/.zshrc)"
  else
    echo "‚ùå ~/.zshrc is not a symlink"
  fi
  
  if [[ -L ~/.p10k.zsh ]]; then
    echo "‚úÖ ~/.p10k.zsh ‚Üí $(readlink ~/.p10k.zsh)"
  else
    echo "‚ùå ~/.p10k.zsh is not a symlink"
  fi
  
  if [[ -L ~/.config/doom ]]; then
    echo "‚úÖ ~/.config/doom ‚Üí $(readlink ~/.config/doom)"
  else
    echo "‚ùå ~/.config/doom is not a symlink"
  fi
  
  # Check backup system
  local backup_dir="$HOME/.config-backups"
  if [[ -d "$backup_dir/.git" ]]; then
    echo ""
    echo "üíæ Backup system: active ($backup_dir)"
  else
    echo ""
    echo "‚ö†Ô∏è  Backup system: not initialized"
  fi
}

config-restore() {
  local backup_dir="$HOME/.config-backups"
  
  if [[ ! -d "$backup_dir/.git" ]]; then
    echo "‚ùå No backup repository found. Run config-backup first."
    return 1
  fi
  
  if ! command -v fzf >/dev/null 2>&1; then
    echo "‚ùå fzf required for interactive restore. Install with: sudo apt install fzf"
    return 1
  fi
  
  cd "$backup_dir"
  
  # List available backups
  local backup_list=$(git log --oneline --format="%h %s" | head -20)
  
  if [[ -z "$backup_list" ]]; then
    echo "‚ùå No backups available"
    return 1
  fi
  
  echo "Available backups:"
  local selected=$(echo "$backup_list" | fzf --prompt="Select backup to restore: ")
  
  if [[ -z "$selected" ]]; then
    echo "‚ùå No backup selected"
    return 1
  fi
  
  local commit_hash=$(echo "$selected" | awk '{print $1}')
  
  echo "üîÑ Restoring configuration from backup: $selected"
  echo "‚ö†Ô∏è  This will overwrite current configurations. Continue? (y/N)"
  read -r confirm
  
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    # Create current backup before restore
    config-backup
    
    # Find files from selected commit
    git show --name-only "$commit_hash" | while read -r file; do
      if [[ "$file" =~ ^zshrc_ ]]; then
        git show "$commit_hash:$file" > ~/.zshrc
        echo "‚úÖ Restored ~/.zshrc"
      elif [[ "$file" =~ ^p10k_ ]]; then
        git show "$commit_hash:$file" > ~/.p10k.zsh
        echo "‚úÖ Restored ~/.p10k.zsh"
      fi
    done
    
    echo "‚úÖ Configuration restored successfully"
    echo "üîÑ Reload your shell: source ~/.zshrc"
  else
    echo "‚ùå Restore cancelled"
  fi
}

config-list-backups() {
  local backup_dir="$HOME/.config-backups"
  
  if [[ ! -d "$backup_dir/.git" ]]; then
    echo "‚ùå No backup repository found"
    return 1
  fi
  
  cd "$backup_dir"
  echo "üìã Available configuration backups:"
  git log --oneline --format="%C(yellow)%h%C(reset) %C(green)%ad%C(reset) %s" --date=short | head -10
}

# Validation functions
validate-zsh-config() {
  local config_file="${1:-$HOME/.zshrc}"
  
  if [[ ! -f "$config_file" ]]; then
    echo "‚ùå Config file not found: $config_file"
    return 1
  fi
  
  echo "üîç Validating zsh configuration..."
  
  # Basic syntax check
  if ! zsh -n "$config_file" 2>/dev/null; then
    echo "‚ùå Syntax errors found in $config_file"
    zsh -n "$config_file"
    return 1
  fi
  
  echo "‚úÖ Zsh syntax validation passed"
  return 0
}

validate-doom-config() {
  local doom_dir="${1:-$HOME/.config/doom}"
  
  if [[ ! -d "$doom_dir" ]]; then
    echo "‚ùå Doom config directory not found: $doom_dir"
    return 1
  fi
  
  echo "üîç Validating Doom Emacs configuration..."
  
  local doom_bin=$(command -v doom || echo "$HOME/.config/emacs/bin/doom")
  
  if [[ ! -x "$doom_bin" ]]; then
    echo "‚ùå Doom binary not found or not executable"
    return 1
  fi
  
  # Run doom doctor to check for issues
  if ! "$doom_bin" doctor >/dev/null 2>&1; then
    echo "‚ö†Ô∏è  Doom doctor found issues:"
    "$doom_bin" doctor
    return 1
  fi
  
  echo "‚úÖ Doom configuration validation passed"
  return 0
}

# Enhanced Doom Emacs testing functions
validate-elisp-syntax() {
  local file="$1"
  
  if [[ ! -f "$file" ]]; then
    echo "‚ùå File not found: $file"
    return 1
  fi
  
  echo "üîç Validating Emacs Lisp syntax: $(basename "$file")"
  
  # Check syntax using emacs batch mode
  if ! emacs --batch --eval "(progn (find-file \"$file\") (emacs-lisp-mode) (check-parens))" 2>/dev/null; then
    echo "‚ùå Syntax errors found in $file"
    return 1
  fi
  
  echo "‚úÖ Emacs Lisp syntax validation passed"
  return 0
}

doom-test-config() {
  echo "üß™ Testing Doom Emacs configuration in isolated environment..."
  
  local test_dir="$HOME/.doom-test"
  local config_dir="~/org/literate-config"
  local timestamp=$(date +"%Y%m%d_%H%M%S")
  
  # Create isolated test environment
  echo "üìÅ Creating test environment: $test_dir"
  rm -rf "$test_dir"
  mkdir -p "$test_dir"
  
  # Tangle configurations to test directory
  echo "üîß Tangling configurations to test environment..."
  cd "$config_dir"
  
  # Create temporary org files that tangle to test directory
  local temp_dir=$(mktemp -d)
  
  for org_file in doom-config.org; do
    if [[ -f "$org_file" ]]; then
      echo "Processing $org_file..."
      # Create modified version that tangles to test directory
      sed "s|~/.config/doom|$test_dir|g" "$org_file" > "$temp_dir/test_$org_file"
      
      # Tangle to test directory
      emacs --batch -l org --eval "(progn (find-file \"$temp_dir/test_$org_file\") (org-babel-tangle))"
    fi
  done
  
  # Validate generated files
  echo "üîç Validating generated configuration files..."
  local validation_passed=true
  
  for elisp_file in "$test_dir"/*.el; do
    if [[ -f "$elisp_file" ]]; then
      if ! validate-elisp-syntax "$elisp_file"; then
        validation_passed=false
      fi
    fi
  done
  
  if [[ "$validation_passed" == "false" ]]; then
    echo "‚ùå Configuration validation failed"
    echo "üìÅ Test files available at: $test_dir"
    rm -rf "$temp_dir"
    return 1
  fi
  
  # Test doom sync in isolated environment
  echo "üîÑ Testing doom sync with test configuration..."
  local doom_bin=$(command -v doom || echo "$HOME/.config/emacs/bin/doom")
  
  if [[ -x "$doom_bin" ]]; then
    # Set DOOMDIR to test directory
    DOOMDIR="$test_dir" "$doom_bin" sync --force 2>/dev/null
    if [[ $? -eq 0 ]]; then
      echo "‚úÖ Doom sync test passed"
    else
      echo "‚ùå Doom sync test failed"
      echo "üìÅ Test files available at: $test_dir"
      rm -rf "$temp_dir"
      return 1
    fi
  else
    echo "‚ö†Ô∏è  Doom binary not found, skipping sync test"
  fi
  
  echo "‚úÖ All tests passed! Configuration is safe to deploy"
  echo "üßπ Cleaning up test environment..."
  rm -rf "$test_dir" "$temp_dir"
  
  return 0
}

doom-stage-config() {
  echo "üé≠ Staging Doom Emacs configuration for testing..."
  
  local staging_dir="$HOME/.doom-staging"
  local config_dir="~/org/literate-config"
  local backup_dir="$HOME/.config/doom.backup.$(date +%Y%m%d_%H%M%S)"
  
  # Create staging directory
  mkdir -p "$staging_dir"
  
  # Backup current config
  if [[ -d "$HOME/.config/doom" ]]; then
    echo "üíæ Backing up current configuration to: $backup_dir"
    cp -r "$HOME/.config/doom" "$backup_dir"
  fi
  
  # Tangle to staging
  echo "üîß Tangling to staging directory..."
  cd "$config_dir"
  
  # Create temporary org files that tangle to staging
  local temp_dir=$(mktemp -d)
  
  for org_file in doom-config.org; do
    if [[ -f "$org_file" ]]; then
      sed "s|~/.config/doom|$staging_dir|g" "$org_file" > "$temp_dir/staging_$org_file"
      emacs --batch -l org --eval "(progn (find-file \"$temp_dir/staging_$org_file\") (org-babel-tangle))"
    fi
  done
  
  # Replace current config with staging
  rm -rf "$HOME/.config/doom"
  mv "$staging_dir" "$HOME/.config/doom"
  
  echo "‚úÖ Configuration staged! Test it now."
  echo "üí° To rollback: mv '$backup_dir' '$HOME/.config/doom'"
  echo "üí° To keep changes: rm -rf '$backup_dir'"
  
  rm -rf "$temp_dir"
}

doom-rollback() {
  echo "üîÑ Rolling back Doom configuration..."
  
  # Find latest backup
  local latest_backup=$(ls -1d "$HOME/.config/doom.backup."* 2>/dev/null | tail -1)
  
  if [[ -z "$latest_backup" ]]; then
    echo "‚ùå No backup found to rollback to"
    return 1
  fi
  
  echo "üìÅ Rolling back to: $latest_backup"
  rm -rf "$HOME/.config/doom"
  mv "$latest_backup" "$HOME/.config/doom"
  
  echo "‚úÖ Rollback completed"
}

doom-list-backups() {
  echo "üìã Available Doom configuration backups:"
  ls -1td "$HOME/.config/doom.backup."* 2>/dev/null | head -10 | while read backup; do
    local timestamp=$(basename "$backup" | sed 's/doom.backup.//')
    local size=$(du -sh "$backup" 2>/dev/null | cut -f1)
    echo "  üìÅ $timestamp ($size)"
  done
  
  if ! ls "$HOME/.config/doom.backup."* >/dev/null 2>&1; then
    echo "  No backups found"
  fi
}

# Emacs daemon management functions
emacs-restart() {
  echo "üîÑ Restarting Emacs daemon..."
  
  # Check if systemd service is available and active
  if systemctl --user is-active emacs.service >/dev/null 2>&1; then
    echo "üìã Using systemd service..."
    systemctl --user restart emacs.service
    
    # Wait a moment and check status
    sleep 2
    if systemctl --user is-active emacs.service >/dev/null 2>&1; then
      echo "‚úÖ Emacs daemon restarted successfully"
      
      # Offer to open new frame
      echo -n "üñºÔ∏è Open new Emacs frame? (y/N): "
      read -r response
      if [[ "$response" =~ ^[Yy]$ ]]; then
        emacs-frame
      fi
    else
      echo "‚ùå Daemon restart failed"
      echo "üí° Check status with: systemctl --user status emacs.service"
    fi
  else
    echo "‚ö†Ô∏è Systemd service not found or inactive"
    echo "üîß Trying alternative restart method..."
    emacs-restart-alternative
  fi
}

emacs-restart-alternative() {
  echo "üîß Alternative restart methods:"
  echo "1) Kill and restart daemon"
  echo "2) Client-based restart"
  echo "3) Manual instructions"
  echo -n "Choose method (1-3): "
  read -r choice
  
  case $choice in
    1)
      echo "üíÄ Killing current Emacs daemon..."
      pkill -f 'emacs.*--daemon' 2>/dev/null
      sleep 2
      echo "üöÄ Starting new daemon..."
      emacs --daemon
      sleep 3
      if pgrep -f 'emacs.*--daemon' >/dev/null; then
        echo "‚úÖ Daemon restarted successfully"
        echo -n "üñºÔ∏è Open new frame? (y/N): "
        read -r response
        if [[ "$response" =~ ^[Yy]$ ]]; then
          emacs-frame
        fi
      else
        echo "‚ùå Failed to start daemon"
      fi
      ;;
    2)
      echo "üîÑ Restarting via emacsclient..."
      emacsclient -e '(kill-emacs)' 2>/dev/null
      sleep 2
      emacs --daemon
      sleep 3
      echo "‚úÖ Daemon restart completed"
      ;;
    3)
      echo "üîß Manual restart instructions:"
      echo "1. Kill daemon: emacsclient -e '(kill-emacs)'"
      echo "2. Start daemon: emacs --daemon"
      echo "3. Open frame: emacsclient -c"
      ;;
    *)
      echo "‚ùå Invalid choice"
      ;;
  esac
}

emacs-frame() {
  echo "üñºÔ∏è Opening new Emacs frame..."
  if command -v emacsclient >/dev/null 2>&1; then
    if emacsclient -c >/dev/null 2>&1; then
      echo "‚úÖ New frame opened"
    else
      echo "‚ùå Failed to open frame"
      echo "üí° Make sure daemon is running: emacs --daemon"
    fi
  else
    echo "‚ùå emacsclient not found"
  fi
}

emacs-status() {
  echo "üìä Emacs daemon status:"
  
  # Check systemd service
  if command -v systemctl >/dev/null 2>&1; then
    local service_status=$(systemctl --user is-active emacs.service 2>/dev/null)
    echo "üîß Systemd service: $service_status"
  fi
  
  # Check daemon process
  if pgrep -f 'emacs.*--daemon' >/dev/null; then
    echo "üü¢ Daemon process: running"
    local pid=$(pgrep -f 'emacs.*--daemon')
    echo "üìã PID: $pid"
  else
    echo "üî¥ Daemon process: not running"
  fi
  
  # Check if client can connect
  if command -v emacsclient >/dev/null 2>&1; then
    if emacsclient -e 't' >/dev/null 2>&1; then
      echo "üü¢ Client connection: OK"
    else
      echo "üî¥ Client connection: failed"
    fi
  fi
}

emacs-kill() {
  echo "üíÄ Stopping Emacs daemon..."
  
  # Try graceful shutdown first
  if command -v emacsclient >/dev/null 2>&1; then
    echo "ü§ù Attempting graceful shutdown..."
    if emacsclient -e '(kill-emacs)' >/dev/null 2>&1; then
      echo "‚úÖ Daemon stopped gracefully"
      return 0
    fi
  fi
  
  # Try systemd service
  if systemctl --user is-active emacs.service >/dev/null 2>&1; then
    echo "üîß Stopping systemd service..."
    systemctl --user stop emacs.service
    echo "‚úÖ Service stopped"
    return 0
  fi
  
  # Force kill as last resort
  echo "‚ö° Force killing daemon process..."
  if pkill -f 'emacs.*--daemon'; then
    echo "‚úÖ Daemon process killed"
  else
    echo "‚ùå No daemon process found"
  fi
}

# Dependency checking and installation utilities
check-dependencies() {
  echo "üîç Checking system dependencies for literate config..."
  
  local missing_tools=()
  local missing_zsh_plugins=()
  
  # Essential tools
  local essential_tools=(git emacs zsh make curl)
  for tool in "${essential_tools[@]}"; do
    if ! command -v "$tool" >/dev/null 2>&1; then
      missing_tools+=("$tool")
    fi
  done
  
  # Optional but recommended tools
  local optional_tools=(fzf tmux yt-dlp gallery-dl direnv uv)
  for tool in "${optional_tools[@]}"; do
    if ! command -v "$tool" >/dev/null 2>&1; then
      missing_tools+=("$tool (optional)")
    fi
  done
  
  # Zsh plugins
  if [[ -d "$ZSH" ]]; then
    [[ ! -d "$ZSH/custom/plugins/zsh-autosuggestions" ]] && missing_zsh_plugins+=("zsh-autosuggestions")
    [[ ! -d "$ZSH/custom/plugins/zsh-syntax-highlighting" ]] && missing_zsh_plugins+=("zsh-syntax-highlighting")
    [[ ! -d "$ZSH/custom/themes/powerlevel10k" ]] && missing_zsh_plugins+=("powerlevel10k")
  fi
  
  # Report findings
  if [[ ${#missing_tools[@]} -eq 0 && ${#missing_zsh_plugins[@]} -eq 0 ]]; then
    echo "‚úÖ All dependencies are installed!"
  else
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
      echo "‚ö†Ô∏è  Missing tools: ${missing_tools[*]}"
    fi
    if [[ ${#missing_zsh_plugins[@]} -gt 0 ]]; then
      echo "‚ö†Ô∏è  Missing zsh plugins: ${missing_zsh_plugins[*]}"
    fi
    echo ""
    echo "üí° Run 'install-dependencies' to install missing components"
  fi
}

install-dependencies() {
  echo "üîß Installing missing dependencies..."
  
  # Install system packages
  local apt_packages=()
  ! command -v git >/dev/null 2>&1 && apt_packages+=(git)
  ! command -v emacs >/dev/null 2>&1 && apt_packages+=(emacs)
  ! command -v zsh >/dev/null 2>&1 && apt_packages+=(zsh)
  ! command -v make >/dev/null 2>&1 && apt_packages+=(make)
  ! command -v curl >/dev/null 2>&1 && apt_packages+=(curl)
  ! command -v fzf >/dev/null 2>&1 && apt_packages+=(fzf)
  ! command -v tmux >/dev/null 2>&1 && apt_packages+=(tmux)
  ! command -v direnv >/dev/null 2>&1 && apt_packages+=(direnv)
  
  if [[ ${#apt_packages[@]} -gt 0 ]]; then
    echo "üì¶ Installing system packages: ${apt_packages[*]}"
    sudo apt update && sudo apt install -y "${apt_packages[@]}"
  fi
  
  # Install Oh My Zsh if not present
  if [[ ! -d "$HOME/.oh-my-zsh" ]]; then
    echo "üì¶ Installing Oh My Zsh..."
    sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended
    export ZSH="$HOME/.oh-my-zsh"
  fi
  
  # Install Zsh plugins
  if [[ -d "$ZSH" ]]; then
    if [[ ! -d "$ZSH/custom/plugins/zsh-autosuggestions" ]]; then
      echo "üì¶ Installing zsh-autosuggestions..."
      git clone https://github.com/zsh-users/zsh-autosuggestions "$ZSH/custom/plugins/zsh-autosuggestions"
    fi
    
    if [[ ! -d "$ZSH/custom/plugins/zsh-syntax-highlighting" ]]; then
      echo "üì¶ Installing zsh-syntax-highlighting..."
      git clone https://github.com/zsh-users/zsh-syntax-highlighting.git "$ZSH/custom/plugins/zsh-syntax-highlighting"
    fi
    
    if [[ ! -d "$ZSH/custom/themes/powerlevel10k" ]]; then
      echo "üì¶ Installing powerlevel10k theme..."
      git clone --depth=1 https://github.com/romkatv/powerlevel10k.git "$ZSH/custom/themes/powerlevel10k"
    fi
  fi
  
  # Install Python tools
  if command -v pip >/dev/null 2>&1; then
    ! command -v yt-dlp >/dev/null 2>&1 && pip install --user yt-dlp
    ! command -v gallery-dl >/dev/null 2>&1 && pip install --user gallery-dl
  fi
  
  # Install uv (Python package manager)
  if ! command -v uv >/dev/null 2>&1; then
    echo "üì¶ Installing uv..."
    curl -LsSf https://astral.sh/uv/install.sh | sh
  fi
  
  echo "‚úÖ Dependency installation completed!"
  echo "üîÑ Please restart your terminal or run 'source ~/.zshrc' to apply changes"
}

setup-literate-config() {
  echo "üöÄ Setting up literate configuration environment..."
  
  # Check current directory
  if [[ ! -f "$(pwd)/Makefile" ]] || [[ ! -f "$(pwd)/doom-config.org" ]]; then
    echo "‚ùå Please run this from the literate-config directory"
    return 1
  fi
  
  # Install dependencies
  install-dependencies
  
  # Ask user about dotfiles setup
  echo ""
  echo "üîó Dotfiles Management Setup:"
  echo "1) Basic backup system (current)"
  echo "2) Enhanced dotfiles with symlinks (recommended)"
  echo -n "Choose setup method (1-2): "
  read -r choice
  
  case $choice in
    1)
      echo "üì¶ Setting up basic backup system..."
      config-backup
      ;;
    2)
      echo "üîó Setting up enhanced dotfiles system..."
      config-init-dotfiles
      echo ""
      echo "üí° Run 'make all-safe' to generate configs, then 'config-sync-to-dotfiles' to sync"
      ;;
    *)
      echo "‚ùå Invalid choice, using basic backup system..."
      config-backup
      ;;
  esac
  
  # Validate current setup
  echo "üîç Validating setup..."
  validate-zsh-config
  
  if command -v doom >/dev/null 2>&1 || [[ -x "$HOME/.config/emacs/bin/doom" ]]; then
    validate-doom-config
  else
    echo "‚ö†Ô∏è  Doom Emacs not found. Install it first if you plan to use Emacs."
  fi
  
  echo ""
  echo "‚úÖ Literate configuration setup completed!"
  echo "üí° Use 'make all-safe' to tangle configurations"
  echo "üí° Use 'config-status' to check your setup"
  echo "üí° Use 'SPC r d' in Emacs to reload with the enhanced function"
}

# Enhanced reload workflow that integrates with dotfiles
config-enhanced-reload() {
  echo "üöÄ Enhanced configuration reload with dotfiles integration..."
  
  local dotfiles_dir="$HOME/.dotfiles"
  local config_source="$HOME/org/literate-config"
  
  # Step 1: Backup current state
  echo "üì¶ Creating backup..."
  config-backup
  
  # Step 2: Generate new configs
  echo "üîß Generating configurations..."
  cd "$config_source"
  make all-safe
  
  # Step 3: Handle dotfiles integration
  if [[ -d "$dotfiles_dir/.git" ]]; then
    echo "üîó Syncing to dotfiles repository..."
    config-sync-to-dotfiles
    echo "üîó Recreating symlinks..."
    config-create-symlinks
  else
    echo "‚ÑπÔ∏è  No dotfiles repository found (using direct file management)"
  fi
  
  # Step 4: Validate
  echo "üîç Validating new configuration..."
  if validate-zsh-config; then
    echo "‚úÖ Zsh configuration validated"
  else
    echo "‚ùå Zsh validation failed"
    return 1
  fi
  
  if command -v doom >/dev/null 2>&1 || [[ -x "$HOME/.config/emacs/bin/doom" ]]; then
    if validate-doom-config; then
      echo "‚úÖ Doom configuration validated"
    else
      echo "‚ùå Doom validation failed"
      return 1
    fi
  fi
  
  echo "‚úÖ Enhanced reload completed successfully!"
  echo "üîÑ Reload your shell: source ~/.zshrc or restart terminal"
}

#+end_src

---

** Powerlevel10k configuration

(p10k configuration is generated automatically, no need to tangle)

- File: `~/.p10k.zsh`
- If you need to regenerate it:

#+PROPERTY: header-args :results none
#+begin_src shell
#p10k configure
#+end_src

---

** Notes

- You can add additional sections like Functions, Exports, or Custom Keybindings later.
- `.p10k.zsh` is handled separately to avoid manual conflicts.
- Always reload with:

#+PROPERTY: header-args :results none
#+begin_src shell
source ~/.zshrc
#+end_src

Happy hacking! üöÄ
